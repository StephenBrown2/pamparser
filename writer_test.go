package pamparser

import (
	"strings"
	"testing"
)

func TestWriter_FormatRule(t *testing.T) {
	writer := NewWriter()

	tests := []struct {
		name     string
		expected string
		rule     Rule
	}{
		{
			name: "simple pam.conf rule",
			rule: Rule{
				Service:    "login",
				Type:       ModuleTypeAuth,
				Control:    Control{Simple: ptrControlType(ControlRequired)},
				ModulePath: "pam_unix.so",
				Arguments:  []string{"nullok"},
			},
			expected: "login auth required pam_unix.so nullok",
		},
		{
			name: "pam.d rule with comment",
			rule: Rule{
				Type:       ModuleTypeAuth,
				Control:    Control{Simple: ptrControlType(ControlRequired)},
				ModulePath: "pam_unix.so",
				Comment:    "Unix authentication",
			},
			expected: "auth required pam_unix.so # Unix authentication",
		},
		{
			name: "optional control",
			rule: Rule{
				Type:       ModuleTypeAuth,
				Control:    Control{Simple: ptrControlType(ControlOptional), Optional: true},
				ModulePath: "pam_ldap.so",
			},
			expected: "auth -optional pam_ldap.so",
		},
		{
			name: "complex control",
			rule: Rule{
				Type: ModuleTypeAuth,
				Control: Control{
					Complex: map[ReturnValue]any{
						ReturnSuccess: ActionOK,
						ReturnDefault: ActionBad,
					},
				},
				ModulePath: "pam_unix.so",
			},
			expected: "auth [default=bad success=ok] pam_unix.so",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := writer.formatRule(tt.rule)
			if result != tt.expected {
				t.Errorf("Expected: %s\nGot: %s", tt.expected, result)
			}
		})
	}
}

func TestWriter_FormatArguments(t *testing.T) {
	writer := NewWriter()

	tests := []struct {
		name     string
		expected string
		args     []string
	}{
		{
			name:     "simple arguments",
			args:     []string{"nullok", "try_first_pass"},
			expected: "nullok try_first_pass",
		},
		{
			name:     "argument with spaces",
			args:     []string{"query=select * from users"},
			expected: "[query=select * from users]",
		},
		{
			name:     "argument with brackets",
			args:     []string{"message=Hello ] World"},
			expected: "[message=Hello \\] World]",
		},
		{
			name:     "empty",
			args:     []string{},
			expected: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := writer.formatArguments(tt.args)
			if result != tt.expected {
				t.Errorf("Expected: %s\nGot: %s", tt.expected, result)
			}
		})
	}
}

func TestWriter_WriteConfig(t *testing.T) {
	writer := NewWriter()

	config := &Config{
		Comments: []string{"PAM configuration", "Generated by test"},
		Rules: []Rule{
			{
				Service:    "login",
				Type:       ModuleTypeAuth,
				Control:    Control{Simple: ptrControlType(ControlRequired)},
				ModulePath: "pam_unix.so",
				Arguments:  []string{"nullok"},
			},
			{
				Service:    "login",
				Type:       ModuleTypeAccount,
				Control:    Control{Simple: ptrControlType(ControlRequired)},
				ModulePath: "pam_unix.so",
			},
		},
	}

	var buf strings.Builder
	err := writer.Write(config, &buf)
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}

	result := buf.String()
	lines := strings.Split(strings.TrimSpace(result), "\n")

	if len(lines) < 4 {
		t.Errorf("Expected at least 4 lines, got %d", len(lines))
	}

	if !strings.HasPrefix(lines[0], "# PAM configuration") {
		t.Errorf("Expected first line to be comment, got: %s", lines[0])
	}

	// After sorting, account rule should come before auth rule
	var accountLineFound, authLineFound bool
	var accountLineIndex, authLineIndex int

	for i, line := range lines {
		if strings.Contains(line, "account") && strings.Contains(line, "required") {
			accountLineFound = true
			accountLineIndex = i
		}
		if strings.Contains(line, "auth") && strings.Contains(line, "required") {
			authLineFound = true
			authLineIndex = i
		}
	}

	if !accountLineFound || !authLineFound {
		t.Errorf("Expected both account and auth rules to be found")
	}

	if accountLineIndex >= authLineIndex {
		t.Errorf("Expected account rule to come before auth rule, but account is at line %d and auth is at line %d", accountLineIndex, authLineIndex)
	}
}

func TestWriter_LineContinuation(t *testing.T) {
	writer := NewWriter()
	writer.MaxLineLength = 40 // Short length to force continuation

	rule := Rule{
		Type:       ModuleTypeAuth,
		Control:    Control{Simple: ptrControlType(ControlRequired)},
		ModulePath: "pam_mysql.so",
		Arguments:  []string{"user=test", "passwd=secret", "db=testdb", "query=select user from users where name='test'"},
	}

	ruleLine := writer.formatRule(rule)
	lines := writer.handleLineContinuation(ruleLine)

	if len(lines) < 2 {
		t.Errorf("Expected multiple lines due to continuation, got %d", len(lines))
	}

	// Check that all but the last line end with backslash
	for i := range len(lines) - 1 {
		if !strings.HasSuffix(lines[i], " \\") {
			t.Errorf("Line %d should end with backslash: %s", i, lines[i])
		}
	}
}

func TestWriter_FormatControlEdgeCases(t *testing.T) {
	writer := NewWriter()

	// Test complex control with jump
	complexControl := Control{
		Complex: map[ReturnValue]any{
			ReturnSuccess: 2, // Jump value
			ReturnDefault: ActionBad,
		},
	}

	result := writer.formatControl(complexControl)
	if !strings.Contains(result, "success=2") {
		t.Errorf("Expected jump value in complex control, got: %s", result)
	}
}

func TestWriter_WriteConfigEdgeCases(t *testing.T) {
	writer := NewWriter()

	// Test with nil config
	var buf strings.Builder
	err := writer.Write(nil, &buf)
	if err == nil {
		t.Error("Expected error when writing nil config")
	}

	// Test WriteString with nil config
	_, err = writer.WriteString(nil)
	if err == nil {
		t.Error("Expected error when writing nil config to string")
	}
}

func TestNegativeModuleTypeSorting(t *testing.T) {
	// Test that negative module types sort in the same position as their positive counterparts
	config := &Config{
		Rules: []Rule{
			{Type: "session", ModulePath: "pam_unix.so"},
			{Type: "-session", ModulePath: "pam_systemd.so"},
			{Type: "auth", ModulePath: "pam_unix.so"},
			{Type: "-auth", ModulePath: "pam_ldap.so"},
			{Type: "account", ModulePath: "pam_unix.so"},
			{Type: "-account", ModulePath: "pam_ldap.so"},
		},
	}

	writer := NewWriter()
	writer.sortRulesByType(config)

	// After sorting, the order should be: account, -account, auth, -auth, session, -session
	expectedOrder := []string{"account", "-account", "auth", "-auth", "session", "-session"}

	if len(config.Rules) != len(expectedOrder) {
		t.Fatalf("Expected %d rules, got %d", len(expectedOrder), len(config.Rules))
	}

	for i, expectedType := range expectedOrder {
		if string(config.Rules[i].Type) != expectedType {
			t.Errorf("Rule %d: expected type '%s', got '%s'", i, expectedType, config.Rules[i].Type)
		}
	}

	// Test that GetModuleTypeOrder returns same values for negative and positive types
	testTypes := []ModuleType{"account", "auth", "session", "password"}
	for _, moduleType := range testTypes {
		positiveOrder := GetModuleTypeOrder(moduleType)
		negativeOrder := GetModuleTypeOrder(ModuleType("-" + string(moduleType)))
		if positiveOrder != negativeOrder {
			t.Errorf("Order mismatch for %s: positive=%d, negative=%d", moduleType, positiveOrder, negativeOrder)
		}
	}
}

func TestSortRulesByTypeEdgeCases(t *testing.T) {
	writer := NewWriter()

	// Test with empty config
	config := &Config{Rules: []Rule{}}
	writer.sortRulesByType(config)
	// Should not panic

	// Test with mixed directive and regular rules
	config = &Config{
		Rules: []Rule{
			{Type: ModuleTypeSession, ModulePath: "pam_unix.so"},
			{IsDirective: true, DirectiveType: "include", DirectiveTarget: "common-auth"},
			{Type: ModuleTypeAuth, ModulePath: "pam_ldap.so"},
		},
	}

	writer.sortRulesByType(config)

	// Directives should be at the end
	lastRule := config.Rules[len(config.Rules)-1]
	if !lastRule.IsDirective {
		t.Error("Expected directive to be sorted to the end")
	}
}
